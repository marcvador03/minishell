/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokens.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mfleury <mfleury@student.42barcelona.com>  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/07 14:31:45 by mfleury           #+#    #+#             */
/*   Updated: 2025/01/21 21:59:36 by mfleury          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_tokens(t_shell *sh, int level, int status);
int	subshell(t_shell *sh);

static int	exec_token_fork(t_shell *sh, int level, int status)
{
	pid_t	pid;
	int		wstatus;

	pid = fork();
	if (pid == -1)
		flush_errors("", -1, "");
	if (pid == 0)
		exit(execute_tokens(sh, ++level, status));
	waitpid(pid, &wstatus, 0);
	if (WIFEXITED(wstatus))
		return (WEXITSTATUS(wstatus));
	return (-1);
}

static t_shell	*move_sh(t_shell *sh, int *status, int level)
{
	if ((*status != 0 && sh->tk == 1) || (*status == 0 && sh->tk == 0))
		*status = exec_token_fork(sh, level, *status);
	while (sh != NULL && (sh->bracket[0] - sh->bracket[1] > level))
	{
		sh->l_status = *status;
		sh = sh->next;
	}
	if (sh != NULL)
	{
		sh->l_status = *status;
		sh = sh->next;
	}
	return (sh);
}

int	execute_tokens(t_shell *sh, int level, int status)
{
	if (sh != sh->head)
		status = sh->l_status;
	while (sh != NULL)
	{
		while (sh != NULL && sh->bracket[0] > level)
			sh = move_sh(sh, &status, level);
		if (sh == NULL)
			return (status);
		else if (sh->bracket[0] == level)
		{
			if ((sh->tk == 0 && status == 0) || (sh->tk == 1 && status != 0))
				status = subshell(sh);
			else if (level > 0)
				exit (status);
			sh->pipes = NULL;
		}
		if (sh->bracket[1] > 0 && level > 0)
			exit (status);
		if (sh->exit == 1)
			break ;
		sh = sh->next;
		if (sh != NULL)
			sh->l_status = status;
	}
	return (status);
}
	// function get_shell_redirections
		/*
		if (none_of_char(s_line[q->i], "<,>") == TRUE)
			return (flush_errors("", 250, ""), -1);
		q->k = 0;
		q->prev_pos = q->i;
		while (one_of_char(s_line[q->i], "<,>") == TRUE)
		{
			if (q->k >= 2)
				return (flush_errors("", 250, ""), -1);
			if (s_line[q->i] == '>' && s_line[q->i] == '<')
				return (flush_errors("", 250, ""), -1);
			else if (s_line[q->i] == '<' && s_line[q->i] == '>')
				return (flush_errors("", 250, ""), -1);
			q->k++;
		}
		q->i += sh_skip(s_line, ' ');
		if (s_line[q->i] == '\0')
			return (flush_errors("", 250, ""), -1);
		sh->s_rd[q->j] = ft_substr(s_line, q->prev_pos, q->i - q->prev_pos);
		if (sh->s_rd[q->j] == NULL)
			return (flush_errors("", 202, ""), -1);
		q->prev_pos = q->i;
		while (s_line[q->i] != '\0' && one_of_char(s_line[q->j], "<,>") == TRUE)
			q->i++;
		sh->s_redirs[q->j] = ft_substr(s_line, q->prev_pos, q->i - q->prev_pos);
		if (sh->s_rd[q->j++] == NULL)
			return (flush_errors("", 202, ""), -1);
		if (s_line[q->i] == '\0')
			return (0);
		else if (one_of_char(s_line[q->j], "<,>") == TRUE)
			return (call same function, 0);
	}*/

